
== 进程、线程


== 并行和并发

== 用户态和内核态

== 进程调度算法

- 抢占式调度
SJF（Shortest Job First）
SRTF（Shortest Remaining Time First）
Priority Scheduling（优先级调度）
Multi-level Feedback Queue（多级反馈队列）

- 非抢占式调度
FCFS（First Come First Serve）
Round Robin（轮转法）

不同的调度算法适用于不同的应用场景，选择适合的调度算法需要根据具体需求来决定：
- 对于 实时系统，需要保证任务按时完成，常用的调度算法包括 优先级调度 和 最短作业优先。
- 对于 交互式系统，如多任务桌面操作系统，常用 轮转法 和 多级反馈队列调度。
- 对于需要 平衡效率和公平性 的情况， 多级反馈队列 是一种比较理想的选择。

#table(
  columns: 4,
  // rows: 5,
  
  [场景特征], [推荐算法], [关键参数配置], [性能指标侧重], 
  [硬实时任务], [EDF], [截止时间监测周期], [任务完成率],
  [软实时+交互], [多级优先级], [优先级粒度（如256级）], [响应时间标准差],
  [通用交互式], [MLFQ], [队列层级数（通常3-5层）], [90%响应时间],
  [科学计算集群], [公平共享（Fair Share）], [CPU时间配额（按用户/组）], [吞吐量],
  [低功耗嵌入式], [节能调度], [动态电压频率调整阈值], [能效比（Tasks/Joule）]
  
)



== 进程间的通讯方式
- 管道：内核里的一串缓存，进程间通信通过使用fork创建子进程复制父进程的文件描述符
功能：将前一个命令的输出作为后一个命令的输入
分类：
1. 匿名管道「|」：通信范围在父子间的进程
2. 命名管道（FIFO）：在不相关的进程中也能相互通信
效率低，不适合进程间频繁的交换数据

- 消息队列：保存在内核中的消息链表，不适合较大数据的传输，存在用户态和内核态之间的数据拷贝开销。
通信不及时，附件大小有限制

- 共享内存：拿出一块虚拟地址空间映射到相同的物理内存中

-   信号量：是一个整型计数器，主要用于实现进程间的互斥和同步，而不是用于缓存进程间通信的数据
控制方式：
1. p操作：信号量-1，如果结果`<0`资源被占用进程需要阻塞，反之可以正常执行，进入共享资源前
2.v操作：信号量+1，如果`<=0`说明有阻塞，会唤醒运行，反之没有，离开共享资源后

- 信号：异常情况下的工作模式，需要用信号的方式来通知进程，是进程间通信机制中唯一的异步通信机制 5. 用户进程对信号的处理方式：1.执行默认操作 2.捕捉信号 3.忽略信号

- Socket：跨网络和不同的主机上的进程之间通信
```cpp
int socket(int domain, int type, int protocal)
```

== 进程状态和状态之间的转换

== 作业调度和进程调度

== 异常和中断
异常：是指CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件。
中断：是指一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。

- 内部异常（Exception） ：
也被称为内部中断 或者 软件中断，异常是CPU执行当前指令产生的事件，是同步发生的，与CPU正在执行的指令密切相关。
异常事件可进一步划分为故障（Fault），自陷（Trap），终止（Abort）。

- 外部中断（Interrupt） ：
外部中断来自CPU外部，与具体的指令无关，是随机事件，中断是指外部设备向CPU发出的中断请求（如鼠标点击、键盘按键等），中断提供了外设与CPU交流的机制，它也是一种重要的I/O方式。CPU会在当前指令执行完毕后响应中断请求，进而转移到对应的中断处理程序，处理完毕后返回到发生中断的那条指令的下一条指令（因为被中断指令已经执行完毕）。
按中断请求是否可被屏蔽分类，可分为可屏蔽中断 和 非屏蔽中断。
按中断事件能否直接提供中断服务地址分类，可分为向量中断 和 非向量中断。
按中断处理过程能否被打断分类，可分为单重中断 和 多重中断。


== 银行家算法
银行家算法是一种用于动态资源分配的死锁避免算法，由荷兰科学家 Dijkstra 提出。其核心思想是：对于每次资源申请，系统都要实时判断其是否有死锁风险，如果存在风险，就拒绝该申请；仅在资源分配后系统仍处于安全状态时，才允许分配资源，从而避免死锁。

安全状态定义：存在一个进程执行序列{P1,P2,...,Pn}，使得每个Pi都能获得其最大需求资源并顺利完成。这需要满足两个条件：
- 即时满足：Available ≥ Need[i]（当前资源足够该进程运行）
- 可回收性：进程完成后释放的资源能支持后续进程

涉及到的数据结构
- 系统可用资源向量Available[m]：表示系统中每种资源的可用数量，随着系统资源分配与回收情况的变动而动态变化。
- 最大需求矩阵Max[n][m]：表示系统中 n 个进程中每个进程对 m 类资源的最大需求量。
- 分配矩阵Allocation[n][m]：表示当前每个进程占有的各类资源数量。
- 需求矩阵Need[n][m]：表示进程完成任务还需要每种资源的数量；Need[i][j] = Max[i][j] - Allocation[i][j]。
- work[m]：表示系统中可用于维持进程运行的各类资源的数量，在安全性算法执行前，令 Work = Available；
- finish[n]：表示进程是否已经完成任务，初始值为false。

银行家算法如下：
1. 检查请求是否合法（Request ≤ Need）
2. 检查是否满足 Available ≥ Request
3. 模拟分配：
   - Available = Available - Request
   - Allocation = Allocation + Request
   - Need = Need - Request
4. 执行安全性检查算法
5. 根据检查结果决定回滚或确认分配

安全性检查算法：
准备一个work向量，初始值为Available，它表示系统目前可用的资源数量；
准备一个finish向量，初始值为false，它表示进程是否已经完成任务；
检查进程是否满足条件：
1. 便利所有进程，对于进程i，如果finish[i]为false，则检查Need[i] ≤ work
2. 如果满足，则work = work + Allocation[i]，finish[i] = true
3. 如果不满足，则继续检查下一个进程

最后如果finish[i]都为true，则表示系统处于安全状态，否则处于不安全状态。

这里需要work向量和allocation向量，因为需要模拟当进程i完成后的资源回收和再分配，并且这可以帮助我们找到一个安全的线程执行序列。
例如：
系统有1台可用打印机：
（调整初始状态，Available=1）
#align(center, table(
  columns: 4,
  [进程], [已分配], [最大需求], [还需],
  [P1], [1], [3], [2],
  [P2], [1], [2], [1],
  [P3], [0], [1], [1],
)
)

- 当前可用资源：1
P3请求1台打印机：

预分配检查：
请求量（1） ≤ P3的Need（1） ✔️
请求量（1） ≤ Available（1） ✔️

简单检查（错误方法）：
- - 分配后Available=0
- 检查各进程Need：
- P1需2 > 0 ❌
- P2需1 > 0 ❌
- P3需0 ≤0 ✔️
- 结论：不安全，拒绝请求

银行家算法安全性检查：
模拟分配：
Available = 0

P3 Allocation=1，Need=0

查找安全序列：

P3可立即完成 → 释放1台 → Available=1

P2需1 ≤1 → 完成 → 释放1台 → Available=2

P1需2 ≤2 → 完成

安全序列存在：`<P3, P2, P1>` → 应允许分配

== 进程同步和互斥
进程互斥是指多个进程不能同时进入临界区（访问共享资源）。目的是避免竞争条件和数据不一致的问题。（场景：哲学家进餐问题）
进程同步是为了协调多个进程之间的执行顺序，使它们按一定逻辑合作完成任务。（场景：生产者-消费者问题）
- 临界区（Critical Section）：指访问共享资源（如全局变量、文件、缓冲区）的代码区域。

#figure(
  image("./figs/sync_and_debate.png", width: 34%),
  caption: [进程同步和互斥实现方法（图示提供：卡码笔记）],
)



- 锁机制（Lock/Mutex）：加锁与解锁。
- 信号量（Semaphore）：P/V 操作。
- 自旋锁（Spinlock）：忙等待。
- 原子操作：如 test-and-set、compare-and-swap。
- 管程（Monitor）：一种用于进程同步的高级抽象机制，它将共享资源的访问与管理封装在一个模块中，通过条件变量和同步机制来确保进程对资源的互斥访问。
- 事件机制（Event）
- 条件变量（Condition Variable）
- 通信机制（如管道、消息队列、共享内存等）

线程同步的方式
- 互斥锁： 独占访问，一次只允许一个线程持有锁。如果锁已被占有，其他线程尝试获取时会阻塞等待，直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源；
- 自旋锁： 当一个线程尝试获取已被持有的锁时，它会在一个循环中不断尝试，而不是立即阻塞；
- 读写锁： 分为读操作和写操作，可以同时有多个读线程访问共享内存，但是只能有一个写线程进行对共享内存的写操作；
- 条件变量： 通常和互斥锁搭配使用，
- 信号量： 信号量本质是一个计数器，用于控制多个程序对共享资源的访问。一般分为两种类型：
- 计数信号量：允许对资源进行多次访问，其计数值表示可用资源的数量。
- 二进制信号量（类似于互斥锁）：只允许一个线程访问资源，用于实现互斥。
- 屏障： 一种同步机制，保证所有线程都到达某个同步点后，才能继续执行后续代码。

管程的主要作用包括：
- 互斥访问：保证多个进程不能同时访问同一个共享资源。
- 条件同步：通过条件变量协调多个进程的执行顺序。
- 简化并发编程：通过封装复杂的同步逻辑，提供更易用的接口。



== 什么是死锁，如何预防死锁？
-死锁（Deadlock） 是指两个或多个进程在执行过程中，因为争夺资源而造成的一种互相等待的现象，若无外力干预，它们都将无法继续执行。
产生死锁的四个必要条件：
- 互斥条件（Mutual Exclusion） 每个资源要么已经分配给了一个进程，要么就是可用的（不可同时被两个以上进程使用）。
- 请求与保持条件（Hold and Wait） 一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件（No Preemption） 进程已经获得的资源，在未使用完之前，不能强行剥夺。
- 循环等待条件（Circular Wait） 存在一种进程资源的循环等待链，使得每个进程都等待下一个进程所占有的资源。

预防死锁的方法：
A.破坏必要条件
- 破坏互斥条件：不太现实，部分资源本身就是不能共享的（如打印机）。
- 破坏请求与保持：一次性申请所有资源（代价高，不灵活）。
- 破坏不剥夺条件：当某一进程请求资源失败时，主动释放已占资源。
- 破坏循环等待：对所有资源统一编号，进程必须按照编号递增顺序请求资源。

B.避免死锁
banker's algorithm（银行家算法）

C.死锁检测与恢复
- 允许系统进入死锁状态，定期检测是否存在死锁。
- 检测后通过撤销进程、抢占资源等方式进行恢复。

#table(
  columns: 3,
  [方法], [优点], [缺点],
  [预防死锁], [简单直接，防患于未然], [通常资源利用率低],
  [避免死锁], [动态检测，灵活性好], [实现复杂，运行开销大],
  [检测与恢复], [最大限度提高资源利用率], [存在死锁风险，处理复杂],
)

== PV 操作和应用场景
两者都是针对信号量的原子操作，通过增减信号量值实现资源分配与释放。
-P操作（wait原语 / 等待）：P原语，又称wait原语，用于实现对S值的减1，减1相当于申请并获取一个资源，资源不足则开始等待。
-V操作（signal原语 / 释放）：V原语，又称signal原语，用于实现对S值的加1，加1相当于使用结束并释放一个资源，若有进程在等待该资源，则唤醒一个进程。
-关键特性：
1. 原子性：通过 硬件指令 或 禁用中断 保证 P操作和V操作 不可分割。
2. 阻塞与唤醒：P操作可能阻塞进程，V操作可能唤醒进程。
3. 队列管理：信号量的等待队列通常遵循 FIFO 或 优先级策略。

- 应用（注意信号量的初始值）：
1. 互斥访问（Mutual Exclusion）：
场景：多个进程需互斥访问共享资源（如打印机、共享内存）。
实现：初始化二进制信号量 mutex = 1；每个进程在访问临界区前需对互斥量mutex执行P操作，在退出临界区后需对互斥量mutex执行V操作。

2. 同步协作（Synchronization and Coordination）：
场景：多个进程在执行中有确定的前后关系，例如进程Pa用于拉取数据，进程Pb用于对数据进行处理，那么Pb就必须在Pa之后执行。
实现：可以将同步信号量的初始值置为0，只要进程Pa没有对资源执行V操作，那么进程Pb就会始终在P操作中阻塞等待；只有当进程Pa先执行了V操作，进程Pb才能成功执行P操作，继而去处理数据。

*补充*：
- 信号量机制：
信号量（Semaphore）是一种同步工具，通过PV操作（原子增减操作）协调多进程/线程对共享资源的访问。在操作系统中，信号量是一种关联一类临界资源的数据结构，信号量的不同值表示一个临界资源的不同状态。
分类： 从用途和取值范围出发，可分为二进制信号量 和 计数信号量。 
- 二进制信号量（互斥信号量）：值为0或1，通常会有额外的约束机制确保其值只在0和1之间变化，用于互斥访问（如临界区保护） ；二进制信号量的本质是其逻辑值只有两个状态（可用/不可用），而不是其内部实现值的范围。 
- 计数信号量（同步信号量）：值可正可负，具体取决于其实现机制，用于管理多个同类资源（如缓冲区空槽）；当同步信号量的值大于等于0时，信号量的绝对值表示可用资源的数量；当同步信号量的值小于0时，信号量的值的绝对值就是等待该资源的进程数。 

从实现机制和行为特性出发，可分为整型信号量 和 记录型信号量。 
  - 整型信号量：把信号量定义为一个用于表示资源数目的整数S，对于S的访问（加减）只能通过原语实现；可以把整型信号量机制看作是对S定义了三种操作——①初始化；②减1；③加1。整型信号量只能取非负整数。 
  - 记录型信号量：在整型信号量中，如果S ≤ 0时，P操作会陷入“忙等”状态，不满足同步机制设计准则的“让权等待”准则。记录型信号量在整型信号量的基础上，增加了一个被阻塞进程的队列，用于链接所有等待相应资源的进程，以实现“让权等待”。记录型信号量可正可负。
核心作用：通过PV操作实现进程间的同步与互斥。

- 生产者 - 消费者问题：是对合作进程中内部关系的抽象化，可以描述为一组生产者和一群消费者一起工作，通过一个大小为 n 的有限缓冲区进行生产和消费。一个缓冲区可以容纳 n 个产品，其中生产者负责投放产品，消费者负责消费产品。
- 哲学家进餐问题：是进程同步的一个典型问题，可以描述为有五个哲学家围坐在一起，每两个人中间只有一只筷子，每根筷子都不相同，只有当一个哲学家既拿起他左边的筷子又拿起他右边的筷子时，才能吃饭。如果五个哲学家同时拿起他们左边的筷子，就会出现循环等待的情况，导致死锁发生。
- 读者 - 写者问题：是对数据对象（数据文件或记录）的访问模型，可以描述为有一个共享文件File，允许几个读者进程同时读取File中的内容，但在任何时刻只允许一个写者进程写入或修改File中的内容。当一个进程正在读取File中的内容时，允许其他进程也读取File但不允许其他进程写入或修改File；当一个进程正在对File进行写入或修改时，既不允许其他进程读取File也不允许其他进程写入或修改File

几个问题是什么场景，怎么解决？

== 几种典型的锁
互斥锁：互斥锁是最常见的一种锁类型，用于实现互斥地访问共享资源。在同一时刻，某一共享资源只能由持有锁的进程进行访问，其他进程只能等待锁的释放。
自旋锁：自旋锁是一种基于忙等待的锁，即进程在尝试获取锁时，会不断的查询锁是否被释放，直到获得锁。
其他的锁都是基于这两种锁：
1、读写锁：允许多个进程同时对共享资源做读资源，但是只有一个进程能对共享资源进行写操作。锁的状态分为读和写两个状态。
2、悲观锁：认为存在多个进程会同时对共享资源进行访问，所以每次都先获取锁，然后再获取资源。
3、乐观锁：认为多进程进行争夺共享资源的情况较少，所以先对共享资源进行修改，若存在同时修改的情况再放弃本次操作。

== 什么是管程（Monitor），它在操作系统中有什么作用？
- 管程（Monitor）：一种用于进程同步的高级抽象机制，它将共享资源的访问与管理封装在一个模块中，通过条件变量和同步机制来确保进程对资源的互斥访问。

管程的主要作用包括：
- 互斥访问：保证多个进程不能同时访问同一个共享资源。
- 条件同步：通过条件变量协调多个进程的执行顺序。
- 简化并发编程：通过封装复杂的同步逻辑，提供更易用的接口。

== 虚拟内存

为什么需要虚拟内存：
- 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储
- 虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程;
- 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。

